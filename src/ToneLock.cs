// <auto-generated> ToneLock.cs – CTCSS tone decode/encode helpers and utility shims
// This file is self-contained and provides all members RgrCodec references.
// Derived from TXMAP_A1/B/C and RX map analysis the user supplied.
// If a tone/key is not recognized, methods return "?" (for display) and leave bytes unchanged on writes.
// </auto-generated>

#nullable enable
using System;
using System.Collections.Generic;

namespace RangrApp.Locked
{
    public static class ToneLock
    {
        // UI Menus
        public static readonly string[] ToneMenuTx = new string[] { "0", "67.0", "71.9", "74.4", "77.0", "79.7", "82.5", "85.4", "88.5", "91.5", "94.8", "97.4", "100.0", "103.5", "107.2", "110.9", "114.8", "118.8", "123.0", "127.3", "131.8", "136.5", "141.3", "146.2", "151.4", "156.7", "162.2", "167.9", "173.8", "179.9", "186.2", "192.8", "203.5", "210.7" };
        public static readonly string[] ToneMenuRx = ToneMenuTx;
        public static readonly string[] ToneMenuAll = ToneMenuTx;

        // Remember last channel if the app wants this
        private static int _lastChannel = 0;
        public static void SetLastChannel(int ch) => _lastChannel = ch;

        // --- TX decode ---
        // Key = (B0 bit4, B2 bit2, B3 low 7 bits). Presence flag is B3 bit7; if clear => "0".
        private static readonly Dictionary<(int,int,int), string> TxKeyToTone = new()
        {
            [(0, 0, 0)] = "0",
            [(0, 0, 3)] = "67.0",
            [(1, 0, 44)] = "71.9",
            [(1, 1, 0)] = "74.4",
            [(1, 0, 35)] = "77.0",
            [(1, 0, 16)] = "79.7",
            [(1, 0, 48)] = "82.5",
            [(1, 0, 20)] = "85.4",
            [(1, 1, 7)] = "88.5",
            [(1, 0, 49)] = "91.5",
            [(1, 0, 39)] = "94.8",
            [(1, 1, 17)] = "97.4",
            [(1, 0, 11)] = "100.0",
            [(1, 1, 10)] = "103.5",
            [(1, 1, 27)] = "107.2",
            [(1, 1, 5)] = "110.9",
            [(1, 0, 5)] = "114.8",
            [(1, 0, 31)] = "118.8",
            [(1, 0, 13)] = "123.0",
            [(1, 1, 21)] = "127.3",
            [(1, 1, 29)] = "131.8",
            [(1, 1, 20)] = "136.5",
            [(1, 0, 15)] = "141.3",
            [(1, 0, 9)] = "146.2",
            [(1, 1, 12)] = "151.4",
            [(1, 1, 22)] = "156.7",
            [(1, 0, 6)] = "162.2",
            [(1, 0, 46)] = "167.9",
            [(1, 0, 28)] = "173.8",
            [(1, 1, 26)] = "179.9",
            [(1, 1, 25)] = "186.2",
            [(1, 0, 10)] = "192.8",
            [(1, 1, 1)] = "210.7",
        };

        private static readonly Dictionary<string, (int,int,int)> ToneToTxKey = new(StringComparer.Ordinal)
        {
            ["67.0"] = (0, 0, 3),
            ["71.9"] = (1, 0, 44),
            ["74.4"] = (1, 1, 0),
            ["77.0"] = (1, 0, 35),
            ["79.7"] = (1, 0, 16),
            ["82.5"] = (1, 0, 48),
            ["85.4"] = (1, 0, 20),
            ["88.5"] = (1, 1, 7),
            ["91.5"] = (1, 0, 49),
            ["94.8"] = (1, 0, 39),
            ["97.4"] = (1, 1, 17),
            ["100.0"] = (1, 0, 11),
            ["103.5"] = (1, 1, 10),
            ["107.2"] = (1, 1, 27),
            ["110.9"] = (1, 1, 5),
            ["114.8"] = (1, 0, 5),
            ["118.8"] = (1, 0, 31),
            ["123.0"] = (1, 0, 13),
            ["127.3"] = (1, 1, 21),
            ["131.8"] = (1, 1, 29),
            ["136.5"] = (1, 1, 20),
            ["141.3"] = (1, 0, 15),
            ["146.2"] = (1, 0, 9),
            ["151.4"] = (1, 1, 12),
            ["156.7"] = (1, 1, 22),
            ["162.2"] = (1, 0, 6),
            ["167.9"] = (1, 0, 46),
            ["173.8"] = (1, 0, 28),
            ["179.9"] = (1, 1, 26),
            ["186.2"] = (1, 1, 25),
            ["192.8"] = (1, 0, 10),
            ["210.7"] = (1, 1, 1),
        };

        public static string TxToneFromBytes(byte B0, byte B2, byte B3)
        {
            bool present = (B3 & 0x80) != 0;
            int k0 = (B0 >> 4) & 1;
            int k1 = (B2 >> 2) & 1;
            int k2 = B3 & 0x7F;
            if (!present) return "0";
            if (k0==0 && k1==0 && k2==0) return "0";
            return TxKeyToTone.TryGetValue((k0,k1,k2), out var tone) ? tone : "?";
        }

        // Try to set TX tone; returns true on success. display may be "0" to clear or a known tone string.
        public static bool TrySetTxTone(ref byte B0, ref byte B2, ref byte B3, string? display)
        {
            display ??= "0";
            if (display == "0") { B3 = (byte)(B3 & 0x7F); return true; }
            if (!ToneToTxKey.TryGetValue(display, out var key)) return false;
            // set presence
            B3 = (byte)((B3 & 0x80) | (key.Item3 & 0x7F));
            B3 |= 0x80;
            // embed selector bits without disturbing other bits
            if (key.Item1==0) B0 = (byte)(B0 & ~(1<<4)); else B0 = (byte)(B0 | (1<<4));
            if (key.Item2==0) B2 = (byte)(B2 & ~(1<<2)); else B2 = (byte)(B2 | (1<<2));
            return true;
        }

        // Overload kept to satisfy older call sites; A3 is ignored for TX.
        public static bool TrySetTxTone(ref byte B0, ref byte B2, ref byte B3, ref byte A3, string? display) => TrySetTxTone(ref B0, ref B2, ref B3, display);

        // --- RX decode ---
        // A3 carries the 6-bit RX index in a scrambled order. Bit-positions derived from your RX map files.
        // We expose a conservative decoder: when index==0 -> no tone; if B3 bit0 set -> follow TX;
        // otherwise we'll return "?" to surface unknowns instead of guessing.
        private static int RxIndex(byte A3)
        {
            // bit order (b0..b5) extracted from A3 bits: 3,2,1,0,7,6  (see project notes).
            int b0 = (A3 >> 3) & 1;
            int b1 = (A3 >> 2) & 1;
            int b2 = (A3 >> 1) & 1;
            int b3 = (A3 >> 0) & 1;
            int b4 = (A3 >> 7) & 1;
            int b5 = (A3 >> 6) & 1;
            return (b5<<5)|(b4<<4)|(b3<<3)|(b2<<2)|(b1<<1)|b0;
        }
        private static bool RxFollow(byte B3) => (B3 & 0x01) != 0;
        private static int  RxBank(byte B3)   => (B3 >> 1) & 1; // reserved, not currently used

        public static string RxToneFromBytes(byte A3, byte B3, string txToneIfFollow)
        {
            int idx = RxIndex(A3);
            bool follow = RxFollow(B3);
            if (idx == 0)
                return follow ? (string.IsNullOrWhiteSpace(txToneIfFollow) ? "0" : txToneIfFollow) : "0";
            // Non-zero index: we do not map to a table yet because RX encoding is non-linear per your notes.
            return "?";
        }

        // Basic helper used by RgrCodec in some older revisions; ignore A2 and call the main overload.
        public static string RxToneFromBytes(byte A3, byte A2, byte B3) => RxToneFromBytes(A3, B3, "0");

        // Simple RX writer; we only support clearing or 'follow'.
        public static bool TrySetRxTone(ref byte A3, ref byte B3, string? display)
        {
            display ??= "0";
            if (display == "0") { A3 = 0; B3 = (byte)(B3 & ~0x01); return true; }
            if (string.Equals(display, "follow", StringComparison.OrdinalIgnoreCase)) { B3 = (byte)(B3 | 0x01); return true; }
            return false;
        }

        // --- Utility shims used by RgrCodec (keep here to avoid touching UI code) ---
        public static string ToAsciiHex256(ReadOnlySpan<byte> bytes)
        {
            System.Text.StringBuilder sb = new();
            for (int i = 0; i < bytes.Length; i++)
            {
                if (i>0) sb.Append(' ');
                sb.Append(bytes[i].ToString("X2"));
            }
            return sb.ToString();
        }

        public static string ToX2212Nibbles(ReadOnlySpan<byte> row)
        {
            // Convert 8 "logical" bytes -> 16 big-endian nibbles as ASCII hex.
            Span<byte> tmp = stackalloc byte[row.Length*2];
            for (int i=0;i<row.Length;i++){ tmp[i*2] = (byte)((row[i]>>4)&0xF); tmp[i*2+1] = (byte)(row[i]&0xF);} 
            char[] hex = new char[tmp.Length];
            for (int i=0;i<tmp.Length;i++) hex[i] = (char)(tmp[i] < 10 ? '0'+tmp[i] : 'A'+(tmp[i]-10));
            return new string(hex);
        }

        // Flexible decode that returns just tones; useful for older call sites in RgrCodec.
        public static void DecodeChannel(ReadOnlySpan<byte> row, out string txTone, out string rxTone)
        {
            // row layout: A0..A3, B0..B3; see project notes.
            byte B0=row[4], B2=row[6], B3=row[7], A3=row[3];
            txTone = TxToneFromBytes(B0,B2,B3);
            rxTone = RxToneFromBytes(A3,B3, txTone);
        }

        // Richer overload – also returns cct, ste and a preformatted hex string for the UI,
        // so callers that used to do that in RgrCodec can delegate here without changing the UI layer.
        public static void DecodeChannel(ReadOnlySpan<byte> row, out string txTone, out string rxTone, out int cct, out bool ste, out string hex)
        {
            DecodeChannel(row, out txTone, out rxTone);
            byte A3=row[3], B3=row[7];
            cct = (B3 >> 5) & 0x7;
            ste = (A3 & 0x80) != 0;
            hex = ToAsciiHex256(row);
        }
    }
}