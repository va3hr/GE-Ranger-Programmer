// <auto-generated> ToneLock_Final.cs â€“ CTCSS tone decode/encode helpers and utility shims
// Derived from TXMAP_A1/B/C and RX map analysis. Unknowns display as "?"; true zero displays "0".
// </auto-generated>
#nullable enable
using System;
using System.Collections.Generic;
using System.Text;

namespace RangrApp.Locked
{
    public static class ToneLock
    {
        public static readonly string[] ToneMenuTx = new string[] { "0", "67.0", "71.9", "74.4", "77.0", "79.7", "82.5", "85.4", "88.5", "91.5", "94.8", "97.4", "100.0", "103.5", "107.2", "110.9", "114.8", "118.8", "123.0", "127.3", "131.8", "136.5", "141.3", "146.2", "151.4", "156.7", "162.2", "167.9", "173.8", "179.9", "186.2", "192.8", "203.5", "210.7" };
        public static readonly string[] ToneMenuRx = ToneMenuTx;
        public static readonly string[] ToneMenuAll = ToneMenuTx;

        // --- status shims ---
        public static void SetStatusText(string? text) { }
        public static void SetStatusText(object? _, string? text) { }
        public static void SetLastChannel(int ch) { }
        public static void SetLastChannel(byte[] image128, int ch) { }

        // --- TX mapping: key=(B0.bit4, B2.bit2, B3&0x7F), present=B3.bit7 ---
        private static readonly Dictionary<(int,int,int), string> TxKeyToTone = new()
        {
            [(0, 1, 58)] = "67.0",
            [(0, 0, 58)] = "71.9",
            [(0, 1, 57)] = "74.4",
            [(0, 0, 73)] = "77.0",
            [(0, 1, 40)] = "79.7",
            [(0, 1, 24)] = "82.5",
            [(0, 0, 55)] = "85.4",
            [(0, 1, 71)] = "88.5",
            [(0, 1, 102)] = "91.5",
            [(0, 0, 21)] = "94.8",
            [(0, 1, 53)] = "97.4",
            [(0, 1, 100)] = "100.0",
            [(0, 0, 35)] = "103.5",
            [(0, 1, 83)] = "107.2",
            [(0, 0, 113)] = "110.9",
            [(0, 0, 75)] = "114.8",
            [(1, 1, 48)] = "118.8",
            [(1, 1, 0)] = "123.0",
            [(1, 0, 80)] = "127.3",
            [(0, 0, 47)] = "131.8",
            [(0, 0, 127)] = "136.5",
            [(0, 0, 79)] = "141.3",
            [(0, 1, 30)] = "146.2",
            [(0, 0, 126)] = "151.4",
            [(0, 0, 94)] = "156.7",
            [(0, 0, 61)] = "162.2",
            [(0, 0, 29)] = "167.9",
            [(0, 1, 125)] = "173.8",
            [(0, 1, 108)] = "179.9",
            [(0, 1, 92)] = "186.2",
            [(0, 1, 75)] = "192.8",
            [(1, 0, 81)] = "203.5",
            [(1, 1, 1)] = "210.7",
        };

        private static readonly Dictionary<string, (int,int,int)> ToneToTxKey = new(StringComparer.Ordinal)
        {
            ["67.0"] = (0, 1, 58),
            ["71.9"] = (0, 0, 58),
            ["74.4"] = (0, 1, 57),
            ["77.0"] = (0, 0, 73),
            ["79.7"] = (0, 1, 40),
            ["82.5"] = (0, 1, 24),
            ["85.4"] = (0, 0, 55),
            ["88.5"] = (0, 1, 71),
            ["91.5"] = (0, 1, 102),
            ["94.8"] = (0, 0, 21),
            ["97.4"] = (0, 1, 53),
            ["100.0"] = (0, 1, 100),
            ["103.5"] = (0, 0, 35),
            ["107.2"] = (0, 1, 83),
            ["110.9"] = (0, 0, 113),
            ["114.8"] = (0, 0, 75),
            ["118.8"] = (1, 1, 48),
            ["123.0"] = (1, 1, 0),
            ["127.3"] = (1, 0, 80),
            ["131.8"] = (0, 0, 47),
            ["136.5"] = (0, 0, 127),
            ["141.3"] = (0, 0, 79),
            ["146.2"] = (0, 1, 30),
            ["151.4"] = (0, 0, 126),
            ["156.7"] = (0, 0, 94),
            ["162.2"] = (0, 0, 61),
            ["167.9"] = (0, 0, 29),
            ["173.8"] = (0, 1, 125),
            ["179.9"] = (0, 1, 108),
            ["186.2"] = (0, 1, 92),
            ["192.8"] = (0, 1, 75),
            ["203.5"] = (1, 0, 81),
            ["210.7"] = (1, 1, 1),
        };

        public static string TxToneFromBytes(byte B0, byte B2, byte B3)
        {
            bool present = (B3 & 0x80) != 0;
            int k0 = (B0 >> 4) & 1;
            int k1 = (B2 >> 2) & 1;
            int k2 = B3 & 0x7F;
            if (!present) return "0";
            if (k0==0 && k1==0 && k2==0) return "0";
            return TxKeyToTone.TryGetValue((k0,k1,k2), out var tone) ? tone : "?";
        }
        public static string TxToneFromBytes(byte A1, byte B1) => "?"; // legacy 2-arg should not be used

        public static bool TrySetTxTone(ref byte B0, ref byte B2, ref byte B3, string? display)
        {
            display ??= "0";
            if (display == "0") { B3 = (byte)(B3 & 0x7F); return true; }
            if (!ToneToTxKey.TryGetValue(display, out var key)) return false;
            // set presence and low 7 bits
            B3 = (byte)(0x80 | (key.Item3 & 0x7F));
            // set selector bits
            if (key.Item1==0) B0 = (byte)(B0 & ~(1<<4)); else B0 = (byte)(B0 | (1<<4));
            if (key.Item2==0) B2 = (byte)(B2 & ~(1<<2)); else B2 = (byte)(B2 | (1<<2));
            return true;
        }
        public static bool TrySetTxTone(ref byte B0, ref byte B2, ref byte B3, ref byte A3, string? display) => TrySetTxTone(ref B0, ref B2, ref B3, display);

        // --- RX decode: 6-bit window from A3 bits [6,7,0,1,2,3]; follow=B3.bit0; bank=B3.bit1 ---
        private static int RxIndex(byte A3)
        {
            int b5 = (A3 >> 6) & 1;
            int b4 = (A3 >> 7) & 1;
            int b3 = (A3 >> 0) & 1;
            int b2 = (A3 >> 1) & 1;
            int b1 = (A3 >> 2) & 1;
            int b0 = (A3 >> 3) & 1;
            return (b5<<5)|(b4<<4)|(b3<<3)|(b2<<2)|(b1<<1)|b0;
        }
        private static bool RxFollow(byte B3) => (B3 & 0x01) != 0;
        private static int  RxBank(byte B3)   => (B3 >> 1) & 1; // reserved

        public static string RxToneFromBytes(byte A3, byte B3, string txToneIfFollow)
        {
            int idx = RxIndex(A3);
            bool follow = RxFollow(B3);
            if (idx == 0) return follow ? (string.IsNullOrWhiteSpace(txToneIfFollow) ? "0" : txToneIfFollow) : "0";
            return "?"; // real (bank,idx)->tone mapping to be inserted from RXMAP files
        }
        public static string RxToneFromBytes(byte A3, byte A2, byte B3) => RxToneFromBytes(A3, B3, "0");

        // --- Utility overloads RgrCodec variants expect ---
        public static string ToAsciiHex256(ReadOnlySpan<byte> bytes)
        {
            StringBuilder sb = new(bytes.Length*3);
            for (int i=0;i<bytes.Length;i++){ if (i>0) sb.Append(' '); sb.Append(bytes[i].ToString("X2")); }
            return sb.ToString();
        }
        public static string ToAsciiHex256(byte[] bytes) => ToAsciiHex256((ReadOnlySpan<byte>)bytes);

        public static string ToX2212Nibbles(ReadOnlySpan<byte> row)
        {
            // Emit 16 big-endian nibbles as ASCII (no spaces) for an 8-byte row.
            char[] hex = new char[row.Length*2];
            int j=0;
            for (int i=0;i<row.Length;i++){ int hi=(row[i]>>4)&0xF, lo=row[i]&0xF; hex[j++]=(char)(hi<10?'0'+hi:'A'+(hi-10)); hex[j++]=(char)(lo<10?'0'+lo:'A'+(lo-10)); }
            return new string(hex);
        }
        public static string ToX2212Nibbles(byte[] row) => ToX2212Nibbles((ReadOnlySpan<byte>)row);

        public static void DecodeChannel(ReadOnlySpan<byte> row, out string txTone, out string rxTone)
        {
            byte B0=row[4], B2=row[6], B3=row[7], A3=row[3];
            txTone = TxToneFromBytes(B0,B2,B3);
            rxTone = RxToneFromBytes(A3,B3, txTone);
        }
        public static void DecodeChannel(ReadOnlySpan<byte> row, out string txTone, out string rxTone, out int cct, out bool ste, out string hex)
        {
            DecodeChannel(row, out txTone, out rxTone);
            byte A3=row[3], B3=row[7];
            cct = (B3 >> 5) & 0x7;
            ste = (A3 & 0x80) != 0;
            hex = ToAsciiHex256(row);
        }
    }
}